
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>7.14. Aggregate Functions &#8212; Presto 0.231.1 Documentation</title>
    <link rel="stylesheet" href="../_static/presto.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.231.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7.15. Window Functions" href="window.html" />
    <link rel="prev" title="7.13. Date and Time Functions and Operators" href="datetime.html" /> 
  </head>
  <body>
<div class="header">
    <h1 class="heading"><a href="../index.html">
        <span>Presto 0.231.1 Documentation</span></a></h1>
    <h2 class="heading"><span>7.14. Aggregate Functions</span></h2>
</div>
<div class="topnav">
    
<p class="nav">
    <span class="left">
        &laquo; <a href="datetime.html">7.13. Date and Time Functions and Operators</a>
    </span>
    <span class="right">
        <a href="window.html">7.15. Window Functions</a> &raquo;
    </span>
</p>

</div>
<div class="content">
    
  <div class="section" id="aggregate-functions">
<h1>7.14. Aggregate Functions</h1>
<p>Aggregate functions operate on a set of values to compute a single result.</p>
<p>Except for <a class="reference internal" href="#count" title="count"><code class="xref py py-func docutils literal"><span class="pre">count()</span></code></a>, <a class="reference internal" href="#count_if" title="count_if"><code class="xref py py-func docutils literal"><span class="pre">count_if()</span></code></a>, <a class="reference internal" href="#max_by" title="max_by"><code class="xref py py-func docutils literal"><span class="pre">max_by()</span></code></a>, <a class="reference internal" href="#min_by" title="min_by"><code class="xref py py-func docutils literal"><span class="pre">min_by()</span></code></a> and
<a class="reference internal" href="#approx_distinct" title="approx_distinct"><code class="xref py py-func docutils literal"><span class="pre">approx_distinct()</span></code></a>, all of these aggregate functions ignore null values
and return null for no input rows or when all values are null. For example,
<a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a> returns null rather than zero and <a class="reference internal" href="#avg" title="avg"><code class="xref py py-func docutils literal"><span class="pre">avg()</span></code></a> does not include null
values in the count. The <code class="docutils literal"><span class="pre">coalesce</span></code> function can be used to convert null into
zero.</p>
<p>Some aggregate functions such as <a class="reference internal" href="#array_agg" title="array_agg"><code class="xref py py-func docutils literal"><span class="pre">array_agg()</span></code></a> produce different results
depending on the order of input values. This ordering can be specified by writing
an <a class="reference internal" href="../sql/select.html#order-by-clause"><span class="std std-ref">ORDER BY Clause</span></a> within the aggregate function:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="n">array_agg</span><span class="p">(</span><span class="n">x</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">y</span> <span class="k">DESC</span><span class="p">)</span>
<span class="n">array_agg</span><span class="p">(</span><span class="n">x</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="general-aggregate-functions">
<h2>General Aggregate Functions</h2>
<dl class="function">
<dt id="arbitrary">
<code class="descname">arbitrary</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; [same as input]</dt>
<dd><p>Returns an arbitrary non-null value of <code class="docutils literal"><span class="pre">x</span></code>, if one exists.</p>
</dd></dl>

<dl class="function">
<dt id="array_agg">
<code class="descname">array_agg</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as input]&gt;</dt>
<dd><p>Returns an array created from the input <code class="docutils literal"><span class="pre">x</span></code> elements.</p>
</dd></dl>

<dl class="function">
<dt id="avg">
<code class="descname">avg</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the average (arithmetic mean) of all input values.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">avg</code><span class="sig-paren">(</span><em>time interval type</em><span class="sig-paren">)</span> &#x2192; time interval type</dt>
<dd><p>Returns the average interval length of all input values.</p>
</dd></dl>

<dl class="function">
<dt id="bool_and">
<code class="descname">bool_and</code><span class="sig-paren">(</span><em>boolean</em><span class="sig-paren">)</span> &#x2192; boolean</dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">TRUE</span></code> if every input value is <code class="docutils literal"><span class="pre">TRUE</span></code>, otherwise <code class="docutils literal"><span class="pre">FALSE</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="bool_or">
<code class="descname">bool_or</code><span class="sig-paren">(</span><em>boolean</em><span class="sig-paren">)</span> &#x2192; boolean</dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">TRUE</span></code> if any input value is <code class="docutils literal"><span class="pre">TRUE</span></code>, otherwise <code class="docutils literal"><span class="pre">FALSE</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="checksum">
<code class="descname">checksum</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; varbinary</dt>
<dd><p>Returns an order-insensitive checksum of the given values.</p>
</dd></dl>

<dl class="function">
<dt id="count">
<code class="descname">count</code><span class="sig-paren">(</span><em>*</em><span class="sig-paren">)</span> &#x2192; bigint</dt>
<dd><p>Returns the number of input rows.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">count</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; bigint</dt>
<dd><p>Returns the number of non-null input values.</p>
</dd></dl>

<dl class="function">
<dt id="count_if">
<code class="descname">count_if</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; bigint</dt>
<dd><p>Returns the number of <code class="docutils literal"><span class="pre">TRUE</span></code> input values.
This function is equivalent to <code class="docutils literal"><span class="pre">count(CASE</span> <span class="pre">WHEN</span> <span class="pre">x</span> <span class="pre">THEN</span> <span class="pre">1</span> <span class="pre">END)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="every">
<code class="descname">every</code><span class="sig-paren">(</span><em>boolean</em><span class="sig-paren">)</span> &#x2192; boolean</dt>
<dd><p>This is an alias for <a class="reference internal" href="#bool_and" title="bool_and"><code class="xref py py-func docutils literal"><span class="pre">bool_and()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="geometric_mean">
<code class="descname">geometric_mean</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the geometric mean of all input values.</p>
</dd></dl>

<dl class="function">
<dt id="max_by">
<code class="descname">max_by</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; [same as x]</dt>
<dd><p>Returns the value of <code class="docutils literal"><span class="pre">x</span></code> associated with the maximum value of <code class="docutils literal"><span class="pre">y</span></code> over all input values.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">max_by</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>n</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as x]&gt;</dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">n</span></code> values of <code class="docutils literal"><span class="pre">x</span></code> associated with the <code class="docutils literal"><span class="pre">n</span></code> largest of all input values of <code class="docutils literal"><span class="pre">y</span></code>
in descending order of <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="min_by">
<code class="descname">min_by</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; [same as x]</dt>
<dd><p>Returns the value of <code class="docutils literal"><span class="pre">x</span></code> associated with the minimum value of <code class="docutils literal"><span class="pre">y</span></code> over all input values.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">min_by</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>n</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as x]&gt;</dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">n</span></code> values of <code class="docutils literal"><span class="pre">x</span></code> associated with the <code class="docutils literal"><span class="pre">n</span></code> smallest of all input values of <code class="docutils literal"><span class="pre">y</span></code>
in ascending order of <code class="docutils literal"><span class="pre">y</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="max">
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; [same as input]</dt>
<dd><p>Returns the maximum value of all input values.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as x]&gt;</dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">n</span></code> largest values of all input values of <code class="docutils literal"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="min">
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; [same as input]</dt>
<dd><p>Returns the minimum value of all input values.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as x]&gt;</dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">n</span></code> smallest values of all input values of <code class="docutils literal"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="reduce_agg">
<code class="descname">reduce_agg</code><span class="sig-paren">(</span><em>inputValue T</em>, <em>initialState S</em>, <em>inputFunction(S</em>, <em>T</em>, <em>S)</em>, <em>combineFunction(S</em>, <em>S</em>, <em>S)</em><span class="sig-paren">)</span> &#x2192; S</dt>
<dd><p>Reduces all input values into a single value. <code class="docutils literal"><span class="pre">`inputFunction</span></code> will be invoked
for each input value. In addition to taking the input value, <code class="docutils literal"><span class="pre">inputFunction</span></code>
takes the current state, initially <code class="docutils literal"><span class="pre">initialState</span></code>, and returns the new state.
<code class="docutils literal"><span class="pre">combineFunction</span></code> will be invoked to combine two states into a new state.
The final state is returned:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">reduce_agg</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">VALUES</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="p">)</span> <span class="k">AS</span> <span class="n">t</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">id</span><span class="p">;</span>
<span class="c1">-- (1, 9)</span>
<span class="c1">-- (2, 90)</span>

<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">reduce_agg</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">VALUES</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="p">)</span> <span class="k">AS</span> <span class="n">t</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">id</span><span class="p">;</span>
<span class="c1">-- (1, 24)</span>
<span class="c1">-- (2, 24000)</span>
</pre></div>
</div>
<p>The state type must be a boolean, integer, floating-point, or date/time/interval.</p>
</dd></dl>

<dl class="function">
<dt id="sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; [same as input]</dt>
<dd><p>Returns the sum of all input values.</p>
</dd></dl>

</div>
<div class="section" id="bitwise-aggregate-functions">
<h2>Bitwise Aggregate Functions</h2>
<dl class="function">
<dt id="bitwise_and_agg">
<code class="descname">bitwise_and_agg</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; bigint</dt>
<dd><p>Returns the bitwise AND of all input values in 2’s complement representation.</p>
</dd></dl>

<dl class="function">
<dt id="bitwise_or_agg">
<code class="descname">bitwise_or_agg</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; bigint</dt>
<dd><p>Returns the bitwise OR of all input values in 2’s complement representation.</p>
</dd></dl>

</div>
<div class="section" id="map-aggregate-functions">
<h2>Map Aggregate Functions</h2>
<dl class="function">
<dt id="histogram">
<code class="descname">histogram</code><span class="sig-paren">(</span><em>x) -&gt; map(K</em>, <em>bigint</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a map containing the count of the number of times each input value occurs.</p>
</dd></dl>

<dl class="function">
<dt id="map_agg">
<code class="descname">map_agg</code><span class="sig-paren">(</span><em>key</em>, <em>value) -&gt; map(K</em>, <em>V</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a map created from the input <code class="docutils literal"><span class="pre">key</span></code> / <code class="docutils literal"><span class="pre">value</span></code> pairs.</p>
</dd></dl>

<dl class="function">
<dt id="map_union">
<code class="descname">map_union</code><span class="sig-paren">(</span><em>x(K</em>, <em>V)) -&gt; map(K</em>, <em>V</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the union of all the input maps. If a key is found in multiple
input maps, that key’s value in the resulting map comes from an arbitrary input map.</p>
</dd></dl>

<dl class="function">
<dt id="multimap_agg">
<code class="descname">multimap_agg</code><span class="sig-paren">(</span><em>key</em>, <em>value) -&gt; map(K</em>, <em>array(V)</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a multimap created from the input <code class="docutils literal"><span class="pre">key</span></code> / <code class="docutils literal"><span class="pre">value</span></code> pairs.
Each key can be associated with multiple values.</p>
</dd></dl>

</div>
<div class="section" id="approximate-aggregate-functions">
<h2>Approximate Aggregate Functions</h2>
<dl class="function">
<dt id="approx_distinct">
<code class="descname">approx_distinct</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; bigint</dt>
<dd><p>Returns the approximate number of distinct input values.
This function provides an approximation of <code class="docutils literal"><span class="pre">count(DISTINCT</span> <span class="pre">x)</span></code>.
Zero is returned if all input values are null.</p>
<p>This function should produce a standard error of 2.3%, which is the
standard deviation of the (approximately normal) error distribution over
all possible sets. It does not guarantee an upper bound on the error for
any specific input set.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_distinct</code><span class="sig-paren">(</span><em>x</em>, <em>e</em><span class="sig-paren">)</span> &#x2192; bigint</dt>
<dd><p>Returns the approximate number of distinct input values.
This function provides an approximation of <code class="docutils literal"><span class="pre">count(DISTINCT</span> <span class="pre">x)</span></code>.
Zero is returned if all input values are null.</p>
<p>This function should produce a standard error of no more than <code class="docutils literal"><span class="pre">e</span></code>, which
is the standard deviation of the (approximately normal) error distribution
over all possible sets. It does not guarantee an upper bound on the error
for any specific input set. The current implementation of this function
requires that <code class="docutils literal"><span class="pre">e</span></code> be in the range of <code class="docutils literal"><span class="pre">[0.0040625,</span> <span class="pre">0.26000]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="approx_percentile">
<code class="descname">approx_percentile</code><span class="sig-paren">(</span><em>x</em>, <em>percentage</em><span class="sig-paren">)</span> &#x2192; [same as x]</dt>
<dd><p>Returns the approximate percentile for all input values of <code class="docutils literal"><span class="pre">x</span></code> at the
given <code class="docutils literal"><span class="pre">percentage</span></code>. The value of <code class="docutils literal"><span class="pre">percentage</span></code> must be between zero and
one and must be constant for all input rows.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_percentile</code><span class="sig-paren">(</span><em>x</em>, <em>percentage</em>, <em>accuracy</em><span class="sig-paren">)</span> &#x2192; [same as x]</dt>
<dd><p>As <code class="docutils literal"><span class="pre">approx_percentile(x,</span> <span class="pre">percentage)</span></code>, but with a maximum rank error of
<code class="docutils literal"><span class="pre">accuracy</span></code>. The value of <code class="docutils literal"><span class="pre">accuracy</span></code> must be between zero and one
(exclusive) and must be constant for all input rows. Note that a lower
“accuracy” is really a lower error threshold, and thus more accurate. The
default accuracy is <code class="docutils literal"><span class="pre">0.01</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_percentile</code><span class="sig-paren">(</span><em>x</em>, <em>percentages</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as x]&gt;</dt>
<dd><p>Returns the approximate percentile for all input values of <code class="docutils literal"><span class="pre">x</span></code> at each of
the specified percentages. Each element of the <code class="docutils literal"><span class="pre">percentages</span></code> array must be
between zero and one, and the array must be constant for all input rows.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_percentile</code><span class="sig-paren">(</span><em>x</em>, <em>percentages</em>, <em>accuracy</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as x]&gt;</dt>
<dd><p>As <code class="docutils literal"><span class="pre">approx_percentile(x,</span> <span class="pre">percentages)</span></code>, but with a maximum rank error of
<code class="docutils literal"><span class="pre">accuracy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_percentile</code><span class="sig-paren">(</span><em>x</em>, <em>w</em>, <em>percentage</em><span class="sig-paren">)</span> &#x2192; [same as x]</dt>
<dd><p>Returns the approximate weighed percentile for all input values of <code class="docutils literal"><span class="pre">x</span></code>
using the per-item weight <code class="docutils literal"><span class="pre">w</span></code> at the percentage <code class="docutils literal"><span class="pre">p</span></code>. The weight must be
an integer value of at least one. It is effectively a replication count for
the value <code class="docutils literal"><span class="pre">x</span></code> in the percentile set. The value of <code class="docutils literal"><span class="pre">p</span></code> must be between
zero and one and must be constant for all input rows.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_percentile</code><span class="sig-paren">(</span><em>x</em>, <em>w</em>, <em>percentage</em>, <em>accuracy</em><span class="sig-paren">)</span> &#x2192; [same as x]</dt>
<dd><p>As <code class="docutils literal"><span class="pre">approx_percentile(x,</span> <span class="pre">w,</span> <span class="pre">percentage)</span></code>, but with a maximum rank error of
<code class="docutils literal"><span class="pre">accuracy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_percentile</code><span class="sig-paren">(</span><em>x</em>, <em>w</em>, <em>percentages</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as x]&gt;</dt>
<dd><p>Returns the approximate weighed percentile for all input values of <code class="docutils literal"><span class="pre">x</span></code>
using the per-item weight <code class="docutils literal"><span class="pre">w</span></code> at each of the given percentages specified
in the array. The weight must be an integer value of at least one. It is
effectively a replication count for the value <code class="docutils literal"><span class="pre">x</span></code> in the percentile set.
Each element of the array must be between zero and one, and the array must
be constant for all input rows.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_percentile</code><span class="sig-paren">(</span><em>x</em>, <em>w</em>, <em>percentages</em>, <em>accuracy</em><span class="sig-paren">)</span> &#x2192; array&lt;[same as x]&gt;</dt>
<dd><p>As <code class="docutils literal"><span class="pre">approx_percentile(x,</span> <span class="pre">w,</span> <span class="pre">percentages)</span></code>, but with a maximum rank error of
<code class="docutils literal"><span class="pre">accuracy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">approx_set</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; HyperLogLog</dt>
<dd><p>See <a class="reference internal" href="hyperloglog.html"><span class="doc">HyperLogLog Functions</span></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">merge</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; HyperLogLog</dt>
<dd><p>See <a class="reference internal" href="hyperloglog.html"><span class="doc">HyperLogLog Functions</span></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">merge</code><span class="sig-paren">(</span><em>qdigest(T)) -&gt; qdigest(T</em><span class="sig-paren">)</span></dt>
<dd><p>See <a class="reference internal" href="qdigest.html"><span class="doc">Quantile Digest Functions</span></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">qdigest_agg</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; qdigest&lt;[same as x]&gt;</dt>
<dd><p>See <a class="reference internal" href="qdigest.html"><span class="doc">Quantile Digest Functions</span></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">qdigest_agg</code><span class="sig-paren">(</span><em>x</em>, <em>w</em><span class="sig-paren">)</span> &#x2192; qdigest&lt;[same as x]&gt;</dt>
<dd><p>See <a class="reference internal" href="qdigest.html"><span class="doc">Quantile Digest Functions</span></a>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">qdigest_agg</code><span class="sig-paren">(</span><em>x</em>, <em>w</em>, <em>accuracy</em><span class="sig-paren">)</span> &#x2192; qdigest&lt;[same as x]&gt;</dt>
<dd><p>See <a class="reference internal" href="qdigest.html"><span class="doc">Quantile Digest Functions</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="numeric_histogram">
<code class="descname">numeric_histogram</code><span class="sig-paren">(</span><em>buckets</em>, <em>value</em>, <em>weight</em><span class="sig-paren">)</span> &#x2192; map&lt;double, double&gt;</dt>
<dd><p>Computes an approximate histogram with up to <code class="docutils literal"><span class="pre">buckets</span></code> number of buckets
for all <code class="docutils literal"><span class="pre">value</span></code>s with a per-item weight of <code class="docutils literal"><span class="pre">weight</span></code>.  The keys of the
returned map are roughly the center of the bin, and the entry is the total
weight of the bin.  The algorithm is based loosely on <a class="reference internal" href="#benhaimtomtov2010" id="id1">[BenHaimTomTov2010]</a>.</p>
<p><code class="docutils literal"><span class="pre">buckets</span></code> must be a <code class="docutils literal"><span class="pre">bigint</span></code>. <code class="docutils literal"><span class="pre">value</span></code> and <code class="docutils literal"><span class="pre">weight</span></code> must be numeric.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">numeric_histogram</code><span class="sig-paren">(</span><em>buckets</em>, <em>value</em><span class="sig-paren">)</span> &#x2192; map&lt;double, double&gt;</dt>
<dd><p>Computes an approximate histogram with up to <code class="docutils literal"><span class="pre">buckets</span></code> number of buckets
for all <code class="docutils literal"><span class="pre">value</span></code>s. This function is equivalent to the variant of
<a class="reference internal" href="#numeric_histogram" title="numeric_histogram"><code class="xref py py-func docutils literal"><span class="pre">numeric_histogram()</span></code></a> that takes a <code class="docutils literal"><span class="pre">weight</span></code>, with a per-item weight of <code class="docutils literal"><span class="pre">1</span></code>.
In this case, the total weight in the returned map is the count of items in the bin.</p>
</dd></dl>

</div>
<div class="section" id="statistical-aggregate-functions">
<h2>Statistical Aggregate Functions</h2>
<dl class="function">
<dt id="corr">
<code class="descname">corr</code><span class="sig-paren">(</span><em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns correlation coefficient of input values.</p>
</dd></dl>

<dl class="function">
<dt id="covar_pop">
<code class="descname">covar_pop</code><span class="sig-paren">(</span><em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the population covariance of input values.</p>
</dd></dl>

<dl class="function">
<dt id="covar_samp">
<code class="descname">covar_samp</code><span class="sig-paren">(</span><em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the sample covariance of input values.</p>
</dd></dl>

<dl class="function">
<dt id="entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the log-2 entropy of count input-values.</p>
<div class="math">
\[\mathrm{entropy}(c) = \sum_i \left[ {c_i \over \sum_j [c_j]} \log_2\left({\sum_j [c_j] \over c_i}\right) \right].\]</div>
<p><code class="docutils literal"><span class="pre">c</span></code> must be a <code class="docutils literal"><span class="pre">bigint</span></code> column of non-negative values.</p>
<p>The function ignores any <code class="docutils literal"><span class="pre">NULL</span></code> count. If the sum of non-<code class="docutils literal"><span class="pre">NULL</span></code> counts is 0,
it returns 0.</p>
</dd></dl>

<dl class="function">
<dt id="kurtosis">
<code class="descname">kurtosis</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><blockquote>
<div><p>Returns the excess kurtosis of all input values. Unbiased estimate using
the following expression:</p>
<div class="math">
\[\mathrm{kurtosis}(x) = {n(n+1) \over (n-1)(n-2)(n-3)} { \sum[(x_i-\mu)^4] \over \sigma^4} -3{ (n-1)^2 \over (n-2)(n-3) },\]</div>
</div></blockquote>
<p>where <span class="math">\(\mu\)</span> is the mean, and <span class="math">\(\sigma\)</span> is the standard deviation.</p>
</dd></dl>

<dl class="function">
<dt id="regr_intercept">
<code class="descname">regr_intercept</code><span class="sig-paren">(</span><em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns linear regression intercept of input values. <code class="docutils literal"><span class="pre">y</span></code> is the dependent
value. <code class="docutils literal"><span class="pre">x</span></code> is the independent value.</p>
</dd></dl>

<dl class="function">
<dt id="regr_slope">
<code class="descname">regr_slope</code><span class="sig-paren">(</span><em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns linear regression slope of input values. <code class="docutils literal"><span class="pre">y</span></code> is the dependent
value. <code class="docutils literal"><span class="pre">x</span></code> is the independent value.</p>
</dd></dl>

<dl class="function">
<dt id="skewness">
<code class="descname">skewness</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the skewness of all input values.</p>
</dd></dl>

<dl class="function">
<dt id="stddev">
<code class="descname">stddev</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>This is an alias for <a class="reference internal" href="#stddev_samp" title="stddev_samp"><code class="xref py py-func docutils literal"><span class="pre">stddev_samp()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="stddev_pop">
<code class="descname">stddev_pop</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the population standard deviation of all input values.</p>
</dd></dl>

<dl class="function">
<dt id="stddev_samp">
<code class="descname">stddev_samp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the sample standard deviation of all input values.</p>
</dd></dl>

<dl class="function">
<dt id="variance">
<code class="descname">variance</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>This is an alias for <a class="reference internal" href="#var_samp" title="var_samp"><code class="xref py py-func docutils literal"><span class="pre">var_samp()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="var_pop">
<code class="descname">var_pop</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the population variance of all input values.</p>
</dd></dl>

<dl class="function">
<dt id="var_samp">
<code class="descname">var_samp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the sample variance of all input values.</p>
</dd></dl>

</div>
<div class="section" id="classification-metrics-aggregate-functions">
<h2>Classification Metrics Aggregate Functions</h2>
<p>The following functions each measure how some metric of a binary
<a class="reference external" href="https://en.wikipedia.org/wiki/Confusion_matrix">confusion matrix</a> changes as a function of
classification thresholds. They are meant to be used in conjunction.</p>
<p>For example, to find the <a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall">precision-recall curve</a>, use</p>
<blockquote>
<div><div class="highlight-none"><div class="highlight"><pre><span></span>WITH
    recall_precision AS (
        SELECT
            CLASSIFICATION_RECALL(10000, correct, pred) AS recalls,
            CLASSIFICATION_PRECISION(10000, correct, pred) AS precisions
        FROM
           classification_dataset
    )
SELECT
    recall,
    precision
FROM
    recall_precision
CROSS JOIN UNNEST(recalls, precisions) AS t(recall, precision)
</pre></div>
</div>
</div></blockquote>
<p>To get the corresponding thresholds for these values, use</p>
<blockquote>
<div><div class="highlight-none"><div class="highlight"><pre><span></span>WITH
    recall_precision AS (
        SELECT
            CLASSIFICATION_THRESHOLDS(10000, correct, pred) AS thresholds,
            CLASSIFICATION_RECALL(10000, correct, pred) AS recalls,
            CLASSIFICATION_PRECISION(10000, correct, pred) AS precisions
        FROM
           classification_dataset
    )
SELECT
    threshold,
    recall,
    precision
FROM
    recall_precision
CROSS JOIN UNNEST(thresholds, recalls, precisions) AS t(threshold, recall, precision)
</pre></div>
</div>
</div></blockquote>
<p>To find the <a class="reference external" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">ROC curve</a>, use</p>
<blockquote>
<div><div class="highlight-none"><div class="highlight"><pre><span></span>WITH
    fallout_recall AS (
        SELECT
            CLASSIFICATION_FALLOUT(10000, correct, pred) AS fallouts,
            CLASSIFICATION_RECALL(10000, correct, pred) AS recalls
        FROM
           classification_dataset
    )
SELECT
    fallout
    recall,
FROM
    recall_fallout
CROSS JOIN UNNEST(fallouts, recalls) AS t(fallout, recall)
</pre></div>
</div>
</div></blockquote>
<dl class="function">
<dt id="classification_miss_rate">
<code class="descname">classification_miss_rate</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em>, <em>weight</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>Computes the miss-rate with up to <code class="docutils literal"><span class="pre">buckets</span></code> number of buckets. Returns
an array of miss-rate values.</p>
<p><code class="docutils literal"><span class="pre">y</span></code> should be a boolean outcome value; <code class="docutils literal"><span class="pre">x</span></code> should be predictions, each
between 0 and 1; <code class="docutils literal"><span class="pre">weight</span></code> should be non-negative values, indicating the weight of the instance.</p>
<p>The
<a class="reference external" href="https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#False_positive_and_false_negative_rates">miss-rate</a>
is defined as a sequence whose <span class="math">\(j\)</span>-th entry is</p>
<div class="math">
\[{
    \sum_{i \;|\; x_i \leq t_j \bigwedge y_i = 1} \left[ w_i \right]
    \over
    \sum_{i \;|\; x_i \leq t_j \bigwedge y_i = 1} \left[ w_i \right]
    +
    \sum_{i \;|\; x_i &gt; t_j \bigwedge y_i = 1} \left[ w_i \right]
},\]</div>
<p>where <span class="math">\(t_j\)</span> is the <span class="math">\(j\)</span>-th smallest threshold,
and <span class="math">\(y_i\)</span>, <span class="math">\(x_i\)</span>, and <span class="math">\(w_i\)</span> are the <span class="math">\(i\)</span>-th
entries of <code class="docutils literal"><span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">x</span></code>, and <code class="docutils literal"><span class="pre">weight</span></code>, respectively.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">classification_miss_rate</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>This function is equivalent to the variant of
<a class="reference internal" href="#classification_miss_rate" title="classification_miss_rate"><code class="xref py py-func docutils literal"><span class="pre">classification_miss_rate()</span></code></a> that takes a <code class="docutils literal"><span class="pre">weight</span></code>, with a per-item weight of <code class="docutils literal"><span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="classification_fall_out">
<code class="descname">classification_fall_out</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em>, <em>weight</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>Computes the fall-out with up to <code class="docutils literal"><span class="pre">buckets</span></code> number of buckets. Returns
an array of fall-out values.</p>
<p><code class="docutils literal"><span class="pre">y</span></code> should be a boolean outcome value; <code class="docutils literal"><span class="pre">x</span></code> should be predictions, each
between 0 and 1; <code class="docutils literal"><span class="pre">weight</span></code> should be non-negative values, indicating the weight of the instance.</p>
<p>The
<a class="reference external" href="https://en.wikipedia.org/wiki/Information_retrieval#Fall-out">fall-out</a>
is defined as a sequence whose <span class="math">\(j\)</span>-th entry is</p>
<div class="math">
\[{
    \sum_{i \;|\; x_i \leq t_j \bigwedge y_i = 0} \left[ w_i \right]
    \over
    \sum_{i \;|\; y_i = 0} \left[ w_i \right]
},\]</div>
<p>where <span class="math">\(t_j\)</span> is the <span class="math">\(j\)</span>-th smallest threshold,
and <span class="math">\(y_i\)</span>, <span class="math">\(x_i\)</span>, and <span class="math">\(w_i\)</span> are the <span class="math">\(i\)</span>-th
entries of <code class="docutils literal"><span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">x</span></code>, and <code class="docutils literal"><span class="pre">weight</span></code>, respectively.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">classification_fall_out</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>This function is equivalent to the variant of
<a class="reference internal" href="#classification_fall_out" title="classification_fall_out"><code class="xref py py-func docutils literal"><span class="pre">classification_fall_out()</span></code></a> that takes a <code class="docutils literal"><span class="pre">weight</span></code>, with a per-item weight of <code class="docutils literal"><span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="classification_precision">
<code class="descname">classification_precision</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em>, <em>weight</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>Computes the precision with up to <code class="docutils literal"><span class="pre">buckets</span></code> number of buckets. Returns
an array of precision values.</p>
<p><code class="docutils literal"><span class="pre">y</span></code> should be a boolean outcome value; <code class="docutils literal"><span class="pre">x</span></code> should be predictions, each
between 0 and 1; <code class="docutils literal"><span class="pre">weight</span></code> should be non-negative values, indicating the weight of the instance.</p>
<p>The
<a class="reference external" href="https://en.wikipedia.org/wiki/Positive_and_negative_predictive_values">precision</a>
is defined as a sequence whose <span class="math">\(j\)</span>-th entry is</p>
<div class="math">
\[{
    \sum_{i \;|\; x_i &gt; t_j \bigwedge y_i = 1} \left[ w_i \right]
    \over
    \sum_{i \;|\; x_i &gt; t_j} \left[ w_i \right]
},\]</div>
<p>where <span class="math">\(t_j\)</span> is the <span class="math">\(j\)</span>-th smallest threshold,
and <span class="math">\(y_i\)</span>, <span class="math">\(x_i\)</span>, and <span class="math">\(w_i\)</span> are the <span class="math">\(i\)</span>-th
entries of <code class="docutils literal"><span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">x</span></code>, and <code class="docutils literal"><span class="pre">weight</span></code>, respectively.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">classification_precision</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>This function is equivalent to the variant of
<a class="reference internal" href="#classification_precision" title="classification_precision"><code class="xref py py-func docutils literal"><span class="pre">classification_precision()</span></code></a> that takes a <code class="docutils literal"><span class="pre">weight</span></code>, with a per-item weight of <code class="docutils literal"><span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="classification_recall">
<code class="descname">classification_recall</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em>, <em>weight</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>Computes the recall with up to <code class="docutils literal"><span class="pre">buckets</span></code> number of buckets. Returns
an array of recall values.</p>
<p><code class="docutils literal"><span class="pre">y</span></code> should be a boolean outcome value; <code class="docutils literal"><span class="pre">x</span></code> should be predictions, each
between 0 and 1; <code class="docutils literal"><span class="pre">weight</span></code> should be non-negative values, indicating the weight of the instance.</p>
<p>The
<a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a>
is defined as a sequence whose <span class="math">\(j\)</span>-th entry is</p>
<div class="math">
\[{
    \sum_{i \;|\; x_i &gt; t_j \bigwedge y_i = 1} \left[ w_i \right]
    \over
    \sum_{i \;|\; y_i = 1} \left[ w_i \right]
},\]</div>
<p>where <span class="math">\(t_j\)</span> is the <span class="math">\(j\)</span>-th smallest threshold,
and <span class="math">\(y_i\)</span>, <span class="math">\(x_i\)</span>, and <span class="math">\(w_i\)</span> are the <span class="math">\(i\)</span>-th
entries of <code class="docutils literal"><span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">x</span></code>, and <code class="docutils literal"><span class="pre">weight</span></code>, respectively.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">classification_recall</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>This function is equivalent to the variant of
<a class="reference internal" href="#classification_recall" title="classification_recall"><code class="xref py py-func docutils literal"><span class="pre">classification_recall()</span></code></a> that takes a <code class="docutils literal"><span class="pre">weight</span></code>, with a per-item weight of <code class="docutils literal"><span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="classification_thresholds">
<code class="descname">classification_thresholds</code><span class="sig-paren">(</span><em>buckets</em>, <em>y</em>, <em>x</em><span class="sig-paren">)</span> &#x2192; array&lt;double&gt;</dt>
<dd><p>Computes the thresholds with up to <code class="docutils literal"><span class="pre">buckets</span></code> number of buckets. Returns
an array of threshold values.</p>
<p><code class="docutils literal"><span class="pre">y</span></code> should be a boolean outcome value; <code class="docutils literal"><span class="pre">x</span></code> should be predictions, each
between 0 and 1.</p>
<p>The thresholds are defined as a sequence whose <span class="math">\(j\)</span>-th entry is the <span class="math">\(j\)</span>-th smallest threshold.</p>
</dd></dl>

</div>
<div class="section" id="differential-entropy-functions">
<h2>Differential Entropy Functions</h2>
<p>The following functions approximate the binary <a class="reference external" href="https://en.wikipedia.org/wiki/Differential_entropy">differential entropy</a>.
That is, for a random variable <span class="math">\(x\)</span>, they approximate</p>
<div class="math">
\[h(x) = - \int x \log_2\left(f(x)\right) dx,\]</div>
<p>where <span class="math">\(f(x)\)</span> is the partial density function of <span class="math">\(x\)</span>.</p>
<dl class="function">
<dt id="differential_entropy">
<code class="descname">differential_entropy</code><span class="sig-paren">(</span><em>sample_size</em>, <em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the approximate log-2 differential entropy from a random variable’s sample outcomes. The function internally
creates a reservoir (see <a class="reference internal" href="#black2015" id="id2">[Black2015]</a>), then calculates the
entropy from the sample results by approximating the derivative of the cumulative distribution
(see <a class="reference internal" href="#alizadeh2010" id="id3">[Alizadeh2010]</a>).</p>
<p><code class="docutils literal"><span class="pre">sample_size</span></code> (<code class="docutils literal"><span class="pre">long</span></code>) is the maximal number of reservoir samples.</p>
<p><code class="docutils literal"><span class="pre">x</span></code> (<code class="docutils literal"><span class="pre">double</span></code>) is the samples.</p>
<p>For example, to find the differential entropy of <code class="docutils literal"><span class="pre">x</span></code> of <code class="docutils literal"><span class="pre">data</span></code> using 1000000 reservoir samples, use</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>SELECT
    differential_entropy(1000000, x)
FROM
    data
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <span class="math">\(x\)</span> has a known lower and upper bound,
prefer the versions taking <code class="docutils literal"><span class="pre">(bucket_count,</span> <span class="pre">x,</span> <span class="pre">1.0,</span> <span class="pre">&quot;fixed_histogram_mle&quot;,</span> <span class="pre">min,</span> <span class="pre">max)</span></code>,
or <code class="docutils literal"><span class="pre">(bucket_count,</span> <span class="pre">x,</span> <span class="pre">1.0,</span> <span class="pre">&quot;fixed_histogram_jacknife&quot;,</span> <span class="pre">min,</span> <span class="pre">max)</span></code>,
as they have better convergence.</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">differential_entropy</code><span class="sig-paren">(</span><em>sample_size</em>, <em>x</em>, <em>weight</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the approximate log-2 differential entropy from a random variable’s sample outcomes. The function
internally creates a weighted reservoir (see <a class="reference internal" href="#efraimidis2006" id="id4">[Efraimidis2006]</a>), then calculates the
entropy from the sample results by approximating the derivative of the cumulative distribution
(see <a class="reference internal" href="#alizadeh2010" id="id5">[Alizadeh2010]</a>).</p>
<p><code class="docutils literal"><span class="pre">sample_size</span></code> is the maximal number of reservoir samples.</p>
<p><code class="docutils literal"><span class="pre">x</span></code> (<code class="docutils literal"><span class="pre">double</span></code>) is the samples.</p>
<p><code class="docutils literal"><span class="pre">weight</span></code> (<code class="docutils literal"><span class="pre">double</span></code>) is a non-negative double value indicating the weight of the sample.</p>
<p>For example, to find the differential entropy of <code class="docutils literal"><span class="pre">x</span></code> with weights <code class="docutils literal"><span class="pre">weight</span></code> of <code class="docutils literal"><span class="pre">data</span></code>
using 1000000 reservoir samples, use</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>SELECT
    differential_entropy(1000000, x, weight)
FROM
    data
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <span class="math">\(x\)</span> has a known lower and upper bound,
prefer the versions taking <code class="docutils literal"><span class="pre">(bucket_count,</span> <span class="pre">x,</span> <span class="pre">weight,</span> <span class="pre">&quot;fixed_histogram_mle&quot;,</span> <span class="pre">min,</span> <span class="pre">max)</span></code>,
or <code class="docutils literal"><span class="pre">(bucket_count,</span> <span class="pre">x,</span> <span class="pre">weight,</span> <span class="pre">&quot;fixed_histogram_jacknife&quot;,</span> <span class="pre">min,</span> <span class="pre">max)</span></code>,
as they have better convergence.</p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">differential_entropy</code><span class="sig-paren">(</span><em>bucket_count</em>, <em>x</em>, <em>weight</em>, <em>method</em>, <em>min</em>, <em>max</em><span class="sig-paren">)</span> &#x2192; double</dt>
<dd><p>Returns the approximate log-2 differential entropy from a random variable’s sample outcomes. The function
internally creates a conceptual histogram of the sample values, calculates the counts, and
then approximates the entropy using maximum likelihood with or without Jacknife
correction, based on the <code class="docutils literal"><span class="pre">method</span></code> parameter. If Jacknife correction (see <a class="reference internal" href="#beirlant2001" id="id6">[Beirlant2001]</a>) is used, the
estimate is</p>
<div class="math">
\[n H(x) - (n - 1) \sum_{i = 1}^n H\left(x_{(i)}\right)\]</div>
<p>where <span class="math">\(n\)</span> is the length of the sequence, and <span class="math">\(x_{(i)}\)</span> is the sequence with the <span class="math">\(i\)</span>-th element
removed.</p>
<p><code class="docutils literal"><span class="pre">bucket_count</span></code> (<code class="docutils literal"><span class="pre">long</span></code>) determines the number of histogram buckets.</p>
<p><code class="docutils literal"><span class="pre">x</span></code> (<code class="docutils literal"><span class="pre">double</span></code>) is the samples.</p>
<p><code class="docutils literal"><span class="pre">method</span></code> (<code class="docutils literal"><span class="pre">varchar</span></code>) is either <code class="docutils literal"><span class="pre">'fixed_histogram_mle'</span></code> (for the maximum likelihood estimate)
or <code class="docutils literal"><span class="pre">'fixed_histogram_jacknife'</span></code> (for the jacknife-corrected maximum likelihood estimate).</p>
<p><code class="docutils literal"><span class="pre">min</span></code> and <code class="docutils literal"><span class="pre">max</span></code> (both <code class="docutils literal"><span class="pre">double</span></code>) are the minimal and maximal values, respectively;
the function will throw if there is an input outside this range.</p>
<p><code class="docutils literal"><span class="pre">weight</span></code> (<code class="docutils literal"><span class="pre">double</span></code>) is the weight of the sample, and must be non-negative.</p>
<p>For example, to find the differential entropy of <code class="docutils literal"><span class="pre">x</span></code>, each between <code class="docutils literal"><span class="pre">0.0</span></code> and <code class="docutils literal"><span class="pre">1.0</span></code>,
with weights 1.0 of <code class="docutils literal"><span class="pre">data</span></code> using 1000000 bins and jacknife estimates, use</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>SELECT
    differential_entropy(1000000, x, 1.0, &#39;fixed_histogram_jacknife&#39;, 0.0, 1.0)
FROM
    data
</pre></div>
</div>
<p>To find the differential entropy of <code class="docutils literal"><span class="pre">x</span></code>, each between <code class="docutils literal"><span class="pre">-2.0</span></code> and <code class="docutils literal"><span class="pre">2.0</span></code>,
with weights <code class="docutils literal"><span class="pre">weight</span></code> of <code class="docutils literal"><span class="pre">data</span></code> using 1000000 buckets and maximum-likelihood estimates, use</p>
<blockquote>
<div><div class="highlight-none"><div class="highlight"><pre><span></span>SELECT
    differential_entropy(1000000, x, weight, &#39;fixed_histogram_mle&#39;, -2.0, 2.0)
FROM
    data
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If <span class="math">\(x\)</span> doesn’t have known lower and upper bounds, prefer the versions taking <code class="docutils literal"><span class="pre">(sample_size,</span> <span class="pre">x)</span></code>
(unweighted case) or <code class="docutils literal"><span class="pre">(sample_size,</span> <span class="pre">x,</span> <span class="pre">weight)</span></code> (weighted case), as they use reservoir
sampling which doesn’t require a known range for samples.</p>
<p class="last">Otherwise, if the number of distinct weights is low,
especially if the number of samples is low, consider using the version taking
<code class="docutils literal"><span class="pre">(bucket_count,</span> <span class="pre">x,</span> <span class="pre">weight,</span> <span class="pre">&quot;fixed_histogram_jacknife&quot;,</span> <span class="pre">min,</span> <span class="pre">max)</span></code>, as jacknife bias correction,
is better than maximum likelihood estimation. However, if the number of distinct weights is high,
consider using the version taking <code class="docutils literal"><span class="pre">(bucket_count,</span> <span class="pre">x,</span> <span class="pre">weight,</span> <span class="pre">&quot;fixed_histogram_mle&quot;,</span> <span class="pre">min,</span> <span class="pre">max)</span></code>,
as this will reduce memory and running time.</p>
</div>
</dd></dl>

<hr class="docutils" />
<table class="docutils citation" frame="void" id="alizadeh2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Alizadeh2010]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Alizadeh Noughabi, Hadi &amp; Arghami, N. (2010). “A New Estimator of Entropy”.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="beirlant2001" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[Beirlant2001]</a></td><td>Beirlant, Dudewicz, Gyorfi, and van der Meulen,
“Nonparametric entropy estimation: an overview”, (2001)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="benhaimtomtov2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[BenHaimTomTov2010]</a></td><td>Yael Ben-Haim and Elad Tom-Tov, “A streaming parallel decision tree algorithm”,
J. Machine Learning Research 11 (2010), pp. 849–872.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="black2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Black2015]</a></td><td>Black, Paul E. (26 January 2015). “Reservoir sampling”. Dictionary of Algorithms and Data Structures.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="efraimidis2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[Efraimidis2006]</a></td><td>Efraimidis, Pavlos S.; Spirakis, Paul G. (2006-03-16). “Weighted random sampling with a reservoir”.
Information Processing Letters. 97 (5): 181–185.</td></tr>
</tbody>
</table>
</div>
</div>


</div>
<div class="bottomnav">
    
<p class="nav">
    <span class="left">
        &laquo; <a href="datetime.html">7.13. Date and Time Functions and Operators</a>
    </span>
    <span class="right">
        <a href="window.html">7.15. Window Functions</a> &raquo;
    </span>
</p>

</div>

    <div class="footer" role="contentinfo">
    </div>
  </body>
</html>