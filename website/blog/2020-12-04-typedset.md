---
title: Using OptimizedTypedSet to Improve Map and Array Functions
author: Ying Su
authorURL: https://www.linkedin.com/in/ying-su-b00b81107/
authorFBID: 656599427
---

Ying Su

Function evaluation is a big part of projection CPU cost. Recently we optimized a set of functions using `TypedSet`, e.g.  `map_concat`, `array_union`, `array_intersect`, and `array_except`. By introducing a new `OptimizedTypeSet`, the above functions were improved for 40% to 80% in CPU and wall time as shown in the JMH benchmarks, and the production queries containing these functions improved for about 5% overall. Meanwhile, the reserved memory and allocation rate dropped for 10% and up to 80% respectively. Furthermore, it resolved the long knowing issue of throwing `EXCEEDED_FUNCTION_MEMORY_LIMIT` for large incoming blocks: "The input to function_name is too large. More than 4MB of memory is needed to hold the intermediate hash set.” 

The `OptimizedTypeSet` and improvements to the above mentioned functions are merged to master, and will be available from Presto 0.244.

<!--truncate-->

In this post we will look at the methods used in this improvement.

## Avoid Using Internal BlockBuilder

`TypedSet` has an internal `BlockBuilder` and appends each `Block` position being added to it, as well as an external `BlockBuilder` to construct the results. Block building using `BlockBuilder` is very costly and inefficient, especially when the memory growth was not handled properly. The `BlockBuilder` was needed to keep track of the elements being added, so that it can:

1. Resolve hash table probing collision 
2. Rehash. 

However, both are actually not a problem. In all use cases, whole blocks (instead of several positions of a block) are added to the TypedSet, and the problem of resolving collisions can be resolved by keeping track of the blocks being added. Rehashing is not needed at all since we can know the max number of entries before creating a `TypedSet` for most use cases. 

In the new design, we provided methods that add a whole `Block` with different set operations: 
* union
* intersect
* except

These methods take in a `Block` and remember the positions in the set using `SelectedPositions` objects. The operations can be applied on the same set multiple times, i.e. you can union two Block A and B, then intersect with Block C, then minus(except) Block D. This way the internal operations on the Block elements can be streamlined to more efficient loops. The memory consumption and allocation were also reduced because now we only need to remember the selected positions instead of building a whole new Block.

## Avoid Computing The Hash Positions Multiple Times

Calculating the hash positions took over 60% of these function costs. For some operations like set intersection, the previous implementation requires creating multiple `TypedSet`s and calculating the hash position multiple times. For example, in `array_intersect` function, it builds one `TypedSet` R, and based on the probe result on R, adds new elements to another `TypedSet` L. 

![Remote Exchange](/img/blog/2020-12-04-OptimizedTypedSet/TypedSet.png)

As shown in the above picture, the “Contains” and “Add” operation would both calculate the hash positions. But actually the hashPosition calculated in hashtable A can be reused by hashtable B if the size and hash functions are the same. This hash position indicates the starting position of the linear probing for both hash tables.

![Remote Exchange](/img/blog/2020-12-04-OptimizedTypedSet/OptimizedTypedSet.png)

In the new `OptimizedTypedSet`, set intersect operation was done by creating a HashTable of the same size (size preknown) internally, and contains/add operation share the same hash position calculation. When the new Hashtable (A) is constructed, the old one (B) will be discarded. 

## Next Steps

The goal of the above PR was to demonstrate the benefit using the OptimizedTypedSet on 4 functions. There are a few other usages, e.g. `MultimapAggregationFunction`, `MapFromEntriesFunction`, etc. After we change them to use the new `OptimizedTypedSet`, the legacy `TypedSet` implementation can be removed.

## Further reading

For more information please refer to the PR https://github.com/prestodb/presto/pull/15362 

